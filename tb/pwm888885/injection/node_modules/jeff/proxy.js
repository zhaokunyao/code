'use strict';

var port = 80;
var port2 = 443;

var x = null;
var net = require('net');
var http = require('http');
var https = require('https');
var zlib = require('zlib');


var https_url_hash = {};


function trimUrl(url) {
	return ((url.indexOf('/') == -1) ? url + '/' : url);
}

function parseResponse(req, res, sRes, is_x) {
	var url = req.headers['host'] + req.url;

	if (sRes.statusCode == 302 || sRes.statusCode == 307) {
		var newUrl = sRes.headers['location'] || '';

		if (/^https:\/\//i.test(newUrl)) {
			var path = newUrl.substr(8);

			var p = path.indexOf('/');
			req.headers['host'] = path.substring(0, p);
			req.url = path.substr(p);

			proxyRequest(req, res, true);

			console.log('%s redirect to `%s`', url, newUrl);
			return;
		}
	}


 	var cookie = sRes.headers['set-cookie'] || [];
	for(var i = cookie.length - 1; i >= 0; --i) {
		cookie[i] = cookie[i].replace('; Secure', '');
	}

 	var content_type = sRes.headers['content-type'] || '';

	if (! /^text\/html/i.test(content_type)) {
		res.writeHead(sRes.statusCode, sRes.headers);
		sRes.pipe(res);
		return;
	}

        // 无需注入的直接返回
        if (!is_x) {
		res.writeHead(sRes.statusCode, sRes.headers);
		sRes.pipe(res);
		return;
        }

 	var enc = sRes.headers['content-encoding'];
	var stream = sRes;

	if (enc) {
		if (/gzip/i.test(enc)) {
			stream = sRes.pipe(zlib.createGunzip() );
		}
		else if (/deflate/i.test(enc)) {
			stream = sRes.pipe(zlib.createInflateRaw() );
		}
	}

 	var data = new Buffer(0);

	stream.on('data', function(chunk) {
		data = Buffer.concat([data, chunk]);
	});

	stream.on('end', function() {
		if (data.length == 0) {
			flush();
			return;
		}

 		var charset = content_type.match(/charset=(.+)/i);
		if (charset) {
			charset = charset[1];
		}

                // 注入
                if (x && is_x) {
		        data = x.go(data, charset);
                }

		var enc = req.headers['accept-encoding'];
		if (enc) {
			if (/gzip/i.test(enc)) {
				enc = zlib.gzip;
				sRes.headers['content-encoding'] = 'gzip';
			}
			else if (/deflate/i.test(enc)) {
				enc = zlib.deflate;
				sRes.headers['content-encoding'] = 'deflate';
			}
			else {
				delete sRes.headers['content-encoding'];
			}
		}

		if (enc) {
			enc(data, function(err, bin) {
				err? BadReq() : flush(bin);
			});
		}
		else {
			flush(data);
		}

	});

	stream.on('error', function(err) {
		console.log('%s parse response err', url);
		res.writeHeader(404);
		res.end();
                
	});

        function flush(data) {
                if (data && data.length > 0) {
                        sRes.headers['content-length'] = data.length;
                }
                res.writeHead(sRes.statusCode, sRes.headers);
                res.end(data);
        }
        
}


function proxyRequest(req, res, isHttps=false) {

	var reqHeader = req.headers;
	var host = reqHeader['host'];
	var url = host + req.url;
	var fromHttpsPage;

	var fullUrl = (isHttps? 'https://' : 'http://') + url;

	console.log('client %s\t%s %s',
		req.connection.remoteAddress,
		req.method,
		fullUrl.substr(0, 100)
	);

	var request = isHttps? https.request : http.request;
	var options = {
		hostname: host,
		path: req.url,
		method: req.method,
		headers: reqHeader
	};

        var is_x = false;

        //  只注入首页.
        if (req.url == '/') {
                is_x = true;
        }

	var proxy = request(options, function(sRes) {
		parseResponse(req, res, sRes, is_x);
	});

	proxy.on('error', function(err) {
		console.log('ERR: %s %s', err, fullUrl);
		console.log('ERR:', reqHeader);
		res.writeHeader(404);
		res.end();
	});

	if (req._send_buf) {
		proxy.end(req._send_buf);
	}
	else {
		var buf = new Buffer(0);

		req.on('data', function(chunk) {
			buf = Buffer.concat([buf, chunk]);
		});

		req.on('end', function() {
			proxy.end(buf);
			req._send_buf = buf;
		});
	}
}


function httpCb(req, res) {
        if (!req.headers['host']) {
                return;
        }

        proxyRequest(req, res, false);
}


function onHttpsError() {
        console.log('https proxy internal error.');
}



function httpsCb(req, res) {
	var proxy;

	req.on('error', onHttpsError);

	var buf = new Buffer(0);
	req.on('data', function(chunk) {
            if (proxy) {
                    return;
            }

            buf = Buffer.concat([buf, chunk]);

            var r = buf.toString().match(/[\w.-]+\.[\w]{2,}/);
            if (!r) {
                    console.log('bad https request.');
                    this.destroy();
                    return;
            }

            var host = r[0];

            console.log('undecoded https request %s', host);

            proxy = net.connect(port2, host, function() {
                    this.write(buf);

                    this.pipe(req);
                    req.pipe(this);

                    buf = null;
            });

            proxy.on('error', onHttpsError);
	});


}


exports.start = function(objX) {
        if (objX) {
                x = objX;
        }
 	var obj     = http.createServer(httpCb);
 	var obj2    = net.createServer(httpsCb);

	obj.listen(port, function() {
		console.log("http proxy started %s:%d", 
                    this.address().address,
                    this.address().port);
	});

	obj2.listen(port2, function() {
		console.log("https proxy started %s:%d", 
                    this.address().address,
                    this.address().port);
	});

	obj.on('error', function() {
		console.log('http proxy failed to start');
	});

	obj2.on('error', function() {
		console.log('https proxy failed to start');
	});

}


